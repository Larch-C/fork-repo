name: Sync All AstrBot Plugins

on:
  workflow_dispatch:          # 手动触发
    inputs:
      dry_run:
        description: '试运行模式（仅显示操作，不实际执行）'
        required: false
        default: false
        type: boolean
      force_sync:
        description: '强制同步所有已fork的仓库'
        required: false
        default: false
        type: boolean
      conflict_resolution:
        description: '重名冲突解决策略'
        required: false
        default: 'rename'
        type: choice
        options:
          - 'skip'           # 跳过冲突仓库
          - 'rename'         # 自动重命名fork
          - 'interactive'    # 记录冲突待手动处理
  schedule:                   # 每小时 UTC 自动同步
    - cron: "0 * * * *"

env:
  PLUGIN_JSON_URL: "https://raw.githubusercontent.com/AstrBotDevs/AstrBot_Plugins_Collection/main/plugins.json"

jobs:
  prepare:
    runs-on: ubuntu-latest
    outputs:
      repos: ${{ steps.list.outputs.repos }}
      total_count: ${{ steps.list.outputs.total_count }}
    steps:
      - name: Fetch plugins.json
        run: |
          echo "📥 正在获取 plugins.json..."
          curl -fsSL "$PLUGIN_JSON_URL" -o plugins.json
          echo "✅ plugins.json 获取完成"
          
      - name: Parse repo list
        id: list
        run: |
          echo "📋 正在解析仓库列表..."
          
          # 提取所有仓库URL并清理格式
          repos=$(jq -r '
            to_entries[] | 
            select(.value.repo != null) | 
            .value.repo
          ' plugins.json | \
          sed 's|git@github.com:|https://github.com/|' | \
          sed 's|\.git$||' | \
          sed 's|/tree/.*||' | \
          sed 's|/blob/.*||' | \
          grep -E '^https://github\.com/[^/]+/[^/]+$' | \
          sort -u)
          
          # 转换为JSON数组格式
          repo_array=$(echo "$repos" | jq -R -s -c 'split("\n") | map(select(. != ""))')
          total_count=$(echo "$repos" | wc -l)
          
          echo "repos=$repo_array" >> $GITHUB_OUTPUT
          echo "total_count=$total_count" >> $GITHUB_OUTPUT
          
          echo "📊 找到 $total_count 个有效的GitHub仓库："
          echo "$repos" | head -10
          if [ $total_count -gt 10 ]; then
            echo "... 和其他 $((total_count - 10)) 个仓库"
          fi

  create-batches:
    runs-on: ubuntu-latest
    needs: prepare
    if: needs.prepare.outputs.total_count > 0
    outputs:
      batches: ${{ steps.batch.outputs.batches }}
      batch_count: ${{ steps.batch.outputs.batch_count }}
    steps:
      - name: Create batches
        id: batch
        run: |
          echo "📦 正在创建批次..."
          
          # 读取仓库列表
          repos='${{ needs.prepare.outputs.repos }}'
          total_count=${{ needs.prepare.outputs.total_count }}
          
          # 每批处理100个仓库（减少批次大小）
          batch_size=100
          batch_count=$(( (total_count + batch_size - 1) / batch_size ))
          
          echo "总仓库数: $total_count"
          echo "批次大小: $batch_size"
          echo "批次数量: $batch_count"
          
          # 创建批次数组
          batches="["
          for i in $(seq 0 $((batch_count - 1))); do
            start_idx=$((i * batch_size))
            end_idx=$(((i + 1) * batch_size))
            
            # 使用jq提取当前批次的仓库
            batch_repos=$(echo "$repos" | jq -c ".[$start_idx:$end_idx]")
            
            if [ $i -gt 0 ]; then
              batches="$batches,"
            fi
            batches="$batches{\"batch_id\":$i,\"repos\":$batch_repos}"
          done
          batches="$batches]"
          
          echo "batches=$batches" >> $GITHUB_OUTPUT
          echo "batch_count=$batch_count" >> $GITHUB_OUTPUT
          
          echo "✅ 创建了 $batch_count 个批次"

  fork-sync:
    runs-on: ubuntu-latest
    needs: [prepare, create-batches]
    if: needs.create-batches.outputs.batch_count > 0
    strategy:
      max-parallel: 2           # 进一步降低并发数
      fail-fast: false         # 某个批次失败不影响其他批次
      matrix:
        batch: ${{ fromJson(needs.create-batches.outputs.batches) }}

    steps:
      - name: Setup environment
        run: |
          echo "BATCH_ID=${{ matrix.batch.batch_id }}" >> $GITHUB_ENV
          echo "📦 处理批次 ${{ matrix.batch.batch_id }}"
          
      - name: Setup GH CLI
        run: |
          # 检查是否有GH_PAT，如果没有则提示用户
          if [ -z "${{ secrets.GH_PAT }}" ]; then
            echo "❌ 错误: 未找到 GH_PAT secret"
            echo "请按照以下步骤设置Personal Access Token:"
            echo "1. 访问 GitHub Settings → Developer settings → Personal access tokens"
            echo "2. 创建新token，需要 repo 和 workflow 权限"
            echo "3. 在仓库设置中添加名为 GH_PAT 的secret"
            exit 1
          fi
          echo "${{ secrets.GH_PAT }}" | gh auth login --with-token
          
      - name: Verify authentication
        run: |
          echo "🔐 验证GitHub认证..."
          gh auth status
          echo "✅ 认证成功"
          
      - name: Batch delay (Rate limiting protection)
        if: ${{ matrix.batch.batch_id != 0 }}
        run: |
          # 每个批次之间延迟，避免rate limit
          delay_seconds=$(( ${{ matrix.batch.batch_id }} * 15 ))
          echo "⏱️  批次 ${{ matrix.batch.batch_id }} 延迟 ${delay_seconds} 秒..."
          sleep $delay_seconds
          
      - name: Process batch repositories
        run: |
          echo "🔄 开始处理批次 ${{ matrix.batch.batch_id }} 的仓库..."
          
          # 创建结果目录
          mkdir -p results
          
          # 获取冲突解决策略
          CONFLICT_STRATEGY="${{ inputs.conflict_resolution || 'rename' }}"
          echo "🎯 冲突解决策略: $CONFLICT_STRATEGY"
          
          # 处理当前批次的所有仓库
          repos='${{ toJson(matrix.batch.repos) }}'
          
          # 设置错误处理
          set +e  # 允许命令失败而不退出脚本
          
          # 初始化计数器
          processed=0
          total_in_batch=$(echo "$repos" | jq -r 'length')
          
          # 自动重命名函数
          find_available_name() {
            local base_name="$1"
            local my_login="$2"
            local suffix_counter=1
            local candidate_name
            
            # 尝试不同的命名策略
            local naming_strategies=(
              "${base_name}-astrbot"
              "${base_name}-fork" 
              "${base_name}-plugin"
              "astrbot-${base_name}"
            )
            
            # 首先尝试预定义的策略
            for strategy in "${naming_strategies[@]}"; do
              if ! timeout 20 gh repo view "${my_login}/${strategy}" >/dev/null 2>&1; then
                echo "$strategy"
                return 0
              fi
            done
            
            # 如果预定义策略都被占用，使用数字后缀
            while true; do
              candidate_name="${base_name}-astrbot-${suffix_counter}"
              if ! timeout 20 gh repo view "${my_login}/${candidate_name}" >/dev/null 2>&1; then
                echo "$candidate_name"
                return 0
              fi
              suffix_counter=$((suffix_counter + 1))
              
              # 防止无限循环
              if [ $suffix_counter -gt 100 ]; then
                echo "${base_name}-$(date +%s)"
                return 0
              fi
            done
          }
          
          echo "$repos" | jq -r '.[]' | while read -r repo_url; do
            processed=$((processed + 1))
            echo "📦 处理仓库 ($processed/$total_in_batch): $repo_url"
            
            # 重置错误标志
            error_occurred=false
            status="unknown"
            message="处理中..."
            final_fork_name=""
            renamed=false
            
            # 提取仓库信息
            owner_repo=${repo_url#*github.com/}
            owner_repo=${owner_repo%/}
            owner=$(echo "$owner_repo" | cut -d/ -f1)
            repo=$(echo "$owner_repo" | cut -d/ -f2)
            
            # 添加超时和重试机制
            retry_count=0
            max_retries=3
            
            while [ $retry_count -lt $max_retries ]; do
              echo "🔄 尝试 $((retry_count + 1))/$max_retries: $owner_repo"
              
              # 检查原始仓库是否存在（添加超时）
              if timeout 30 gh repo view "$owner_repo" --json name >/dev/null 2>&1; then
                echo "✅ 原始仓库存在: $owner_repo"
                break
              else
                if [ $retry_count -eq $((max_retries - 1)) ]; then
                  echo "❌ 原始仓库不存在或无法访问: $owner_repo"
                  status="not_found"
                  message="原始仓库不存在或无法访问"
                  error_occurred=true
                else
                  echo "⏳ 重试中..."
                  sleep 5
                fi
                retry_count=$((retry_count + 1))
              fi
            done
            
            # 如果原始仓库不存在，保存结果并继续下一个
            if [ "$error_occurred" = "true" ]; then
              jq -n \
                --arg repo "$owner_repo" \
                --arg owner "$owner" \
                --arg repo_name "$repo" \
                --arg status "$status" \
                --arg message "$message" \
                --arg my_fork "unknown/$repo" \
                --arg final_name "$repo" \
                --argjson renamed false \
                --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                '{
                  repo: $repo,
                  owner: $owner,
                  repo_name: $repo_name,
                  status: $status,
                  message: $message,
                  my_fork: $my_fork,
                  final_fork_name: $final_name,
                  renamed: $renamed,
                  timestamp: $timestamp
                }' > "results/${owner}_${repo}.json"
              
              sleep 2  # 短暂延迟后继续
              continue
            fi
            
            # 获取当前用户信息
            my_login=""
            retry_count=0
            while [ $retry_count -lt $max_retries ] && [ -z "$my_login" ]; do
              my_login=$(timeout 15 gh api user --jq .login 2>/dev/null || echo "")
              if [ -z "$my_login" ]; then
                echo "⏳ 获取用户信息重试中..."
                sleep 3
                retry_count=$((retry_count + 1))
              fi
            done
            
            if [ -z "$my_login" ]; then
              echo "❌ 无法获取用户信息: $owner_repo"
              status="auth_failed"
              message="无法获取用户信息"
              
              jq -n \
                --arg repo "$owner_repo" \
                --arg owner "$owner" \
                --arg repo_name "$repo" \
                --arg status "$status" \
                --arg message "$message" \
                --arg my_fork "unknown/$repo" \
                --arg final_name "$repo" \
                --argjson renamed false \
                --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
                '{
                  repo: $repo,
                  owner: $owner,
                  repo_name: $repo_name,
                  status: $status,
                  message: $message,
                  my_fork: $my_fork,
                  final_fork_name: $final_name,
                  renamed: $renamed,
                  timestamp: $timestamp
                }' > "results/${owner}_${repo}.json"
              
              sleep 2
              continue
            fi
            
            my_fork="${my_login}/$repo"
            final_fork_name="$repo"  # 默认使用原名
            
            # 增强的fork状态检查（添加错误处理）
            fork_exists=false
            fork_status="unknown"
            
            # 检查我的fork是否存在（添加超时和错误处理）
            repo_check_result=""
            retry_count=0
            while [ $retry_count -lt $max_retries ]; do
              repo_check_result=$(timeout 30 gh repo view "$my_fork" --json name,parent,isFork,nameWithOwner 2>/dev/null || echo "ERROR")
              if [ "$repo_check_result" != "ERROR" ] && [ -n "$repo_check_result" ]; then
                break
              else
                echo "⏳ 检查fork状态重试中..."
                sleep 3
                retry_count=$((retry_count + 1))
              fi
            done
            
            if [ "$repo_check_result" != "ERROR" ] && [ -n "$repo_check_result" ]; then
              # 解析仓库信息
              is_fork=$(echo "$repo_check_result" | jq -r '.isFork // false' 2>/dev/null || echo "false")
              parent_name=$(echo "$repo_check_result" | jq -r '.parent.nameWithOwner // empty' 2>/dev/null || echo "")
              
              echo "🔍 检查fork状态: is_fork=$is_fork, parent=$parent_name"
              
              if [ "$is_fork" = "true" ]; then
                if [ -n "$parent_name" ] && [ "$parent_name" = "$owner_repo" ]; then
                  # 完美匹配的fork
                  fork_exists=true
                  fork_status="valid_fork"
                  echo "✅ 已fork且parent匹配: $my_fork <- $owner_repo"
                elif [ -n "$parent_name" ]; then
                  # fork但parent不匹配
                  fork_exists=false
                  fork_status="wrong_parent"
                  echo "⚠️  已fork但parent不匹配: $my_fork (parent: $parent_name, expected: $owner_repo)"
                else
                  # fork但没有parent信息，使用API检查
                  echo "🔍 Fork无parent信息，尝试API检查..."
                  
                  api_info=""
                  retry_count=0
                  while [ $retry_count -lt $max_retries ]; do
                    api_info=$(timeout 20 gh api repos/"$my_fork" --jq '{fork: .fork, parent: .parent.full_name}' 2>/dev/null || echo "ERROR")
                    if [ "$api_info" != "ERROR" ]; then
                      break
                    else
                      echo "⏳ API检查重试中..."
                      sleep 3
                      retry_count=$((retry_count + 1))
                    fi
                  done
                  
                  if [ "$api_info" != "ERROR" ]; then
                    api_parent=$(echo "$api_info" | jq -r '.parent // empty' 2>/dev/null || echo "")
                    
                    if [ -n "$api_parent" ] && [ "$api_parent" = "$owner_repo" ]; then
                      fork_exists=true
                      fork_status="valid_fork_api"
                      echo "✅ API确认为正确的fork: $my_fork <- $api_parent"
                    else
                      fork_exists=false
                      fork_status="invalid_fork"
                      echo "❌ API检查无法确认为有效fork"
                    fi
                  else
                    fork_exists=false
                    fork_status="api_check_failed"
                    echo "❌ API检查失败"
                  fi
                fi
              else
                # 不是fork，是同名的独立仓库
                fork_exists=false
                fork_status="independent_repo"
                echo "⚠️  仓库 $my_fork 存在但不是fork (独立仓库)"
              fi
            else
              # fork不存在
              fork_exists=false
              fork_status="not_exists"
              echo "🆕 尚未fork: $owner_repo"
            fi
            
            # 根据情况执行操作（添加错误处理和自动重命名）
            if [ "${{ inputs.dry_run }}" = "true" ]; then
              # 试运行模式
              if [ "$fork_exists" = "false" ]; then
                if [ "$fork_status" = "wrong_parent" ] || [ "$fork_status" = "independent_repo" ]; then
                  case "$CONFLICT_STRATEGY" in
                    "rename")
                      available_name=$(find_available_name "$repo" "$my_login")
                      final_fork_name="$available_name"
                      renamed=true
                      status="will_fork_renamed"
                      message="将会fork为: $available_name"
                      ;;
                    "skip")
                      status="conflict_detected"
                      message="检测到同名仓库冲突，将跳过"
                      ;;
                    "interactive")
                      status="conflict_pending"
                      message="检测到冲突，待手动处理"
                      ;;
                  esac
                else
                  status="will_fork"
                  message="将会fork"
                fi
              else
                status="will_sync"
                message="已fork，需要时会同步"
              fi
            elif [ "$fork_exists" = "false" ]; then
              # 需要fork
              if [ "$fork_status" = "wrong_parent" ] || [ "$fork_status" = "independent_repo" ]; then
                # 存在冲突，根据策略处理
                case "$CONFLICT_STRATEGY" in
                  "rename")
                    echo "🏷️  检测到重名冲突，启用自动重命名..."
                    
                    # 查找可用的名称
                    available_name=$(find_available_name "$repo" "$my_login")
                    echo "🎯 找到可用名称: $available_name"
                    
                    # 使用新名称fork
                    echo "🍴 正在fork为新名称: $owner_repo -> ${my_login}/${available_name}"
                    
                    fork_output=""
                    fork_exit_code=1
                    retry_count=0
                    
                    while [ $retry_count -lt $max_retries ] && [ $fork_exit_code -ne 0 ]; do
                      echo "🔄 重命名Fork尝试 $((retry_count + 1))/$max_retries"
                      fork_output=$(timeout 60 gh repo fork "$owner_repo" --repo-name "$available_name" --clone=false 2>&1)
                      fork_exit_code=$?
                      
                      if [ $fork_exit_code -eq 0 ]; then
                        echo "✅ 重命名Fork成功: $owner_repo -> ${my_login}/${available_name}"
                        status="forked_renamed"
                        message="重命名fork成功: $available_name"
                        final_fork_name="$available_name"
                        my_fork="${my_login}/${available_name}"
                        renamed=true
                        break
                      else
                        # 检查是否是名称仍然冲突
                        if echo "$fork_output" | grep -q "already exists"; then
                          echo "⚠️  名称 $available_name 仍然冲突，寻找新名称..."
                          available_name=$(find_available_name "$repo" "$my_login")
                          echo "🎯 重新找到可用名称: $available_name"
                        else
                          if [ $retry_count -eq $((max_retries - 1)) ]; then
                            echo "❌ 重命名Fork失败: $owner_repo"
                            echo "错误输出: $fork_output"
                            status="fork_rename_failed"
                            message="重命名fork失败: $(echo "$fork_output" | head -1 | cut -c1-50)"
                          else
                            echo "⏳ 重命名Fork重试中..."
                            sleep 5
                          fi
                          retry_count=$((retry_count + 1))
                        fi
                      fi
                    done
                    ;;
                  "skip")
                    echo "⚠️  跳过fork，存在同名仓库: $my_fork"
                    status="skipped_conflict"
                    message="跳过：存在同名仓库冲突"
                    ;;
                  "interactive")
                    echo "🤔 记录冲突待手动处理: $my_fork"
                    status="conflict_pending"
                    message="冲突待手动处理：存在同名仓库"
                    ;;
                esac
              else
                # 正常fork（添加错误处理和超时）
                echo "🍴 正在fork: $owner_repo"
                
                fork_output=""
                fork_exit_code=1
                retry_count=0
                
                while [ $retry_count -lt $max_retries ] && [ $fork_exit_code -ne 0 ]; do
                  echo "🔄 Fork尝试 $((retry_count + 1))/$max_retries"
                  fork_output=$(timeout 60 gh repo fork "$owner_repo" --clone=false 2>&1)
                  fork_exit_code=$?
                  
                  if [ $fork_exit_code -eq 0 ]; then
                    echo "✅ Fork成功: $owner_repo"
                    status="forked"
                    message="新fork成功"
                    break
                  else
                    # 检查是否是"already exists"错误
                    if echo "$fork_output" | grep -q "already exists"; then
                      echo "ℹ️  Fork已存在，检查状态: $my_fork"
                      status="already_forked"
                      message="Fork已存在"
                      fork_exists=true
                      break
                    else
                      if [ $retry_count -eq $((max_retries - 1)) ]; then
                        echo "❌ Fork失败: $owner_repo"
                        echo "错误输出: $fork_output"
                        status="fork_failed"
                        message="Fork失败: $(echo "$fork_output" | head -1 | cut -c1-50)"
                      else
                        echo "⏳ Fork重试中..."
                        sleep 5
                      fi
                      retry_count=$((retry_count + 1))
                    fi
                  fi
                done
              fi
            else
              # 已fork，执行同步（添加错误处理）
              echo "🔄 正在同步fork: $my_fork"
              
              sync_needed=false
              if [ "${{ inputs.force_sync }}" = "true" ] || [ "${{ github.event_name }}" = "schedule" ]; then
                sync_needed=true
                echo "🔄 强制同步模式"
              fi
              
              if [ "$sync_needed" = "true" ]; then
                # 执行同步（添加超时和重试）
                sync_output=""
                sync_exit_code=1
                retry_count=0
                
                while [ $retry_count -lt $max_retries ] && [ $sync_exit_code -ne 0 ]; do
                  echo "🔄 同步尝试 $((retry_count + 1))/$max_retries"
                  sync_output=$(timeout 120 gh repo sync "$my_fork" --source "$owner_repo" 2>&1)
                  sync_exit_code=$?
                  
                  if [ $sync_exit_code -eq 0 ]; then
                    echo "✅ 同步成功: $my_fork"
                    status="synced"
                    message="同步成功"
                    break
                  else
                    # 检查同步失败的原因
                    if echo "$sync_output" | grep -q "up to date\|already up-to-date"; then
                      echo "ℹ️  已是最新: $my_fork"
                      status="up_to_date"
                      message="已是最新版本"
                      break
                    else
                      if [ $retry_count -eq $((max_retries - 1)) ]; then
                        echo "⚠️  同步失败: $my_fork"
                        echo "错误输出: $sync_output"
                        status="sync_failed"
                        message="同步失败: $(echo "$sync_output" | head -1 | cut -c1-50)"
                      else
                        echo "⏳ 同步重试中..."
                        sleep 10
                      fi
                      retry_count=$((retry_count + 1))
                    fi
                  fi
                done
              else
                # 非强制模式，简单检查
                echo "🔍 检查是否需要同步..."
                if timeout 60 gh repo sync "$my_fork" --source "$owner_repo" 2>/dev/null; then
                  echo "✅ 同步成功: $my_fork"
                  status="synced"
                  message="自动同步成功"
                else
                  echo "ℹ️  无需同步或同步失败: $my_fork"
                  status="up_to_date"
                  message="已是最新或无需同步"
                fi
              fi
            fi
            
            # 保存结果（确保目录存在）
            mkdir -p "results"
            jq -n \
              --arg repo "$owner_repo" \
              --arg owner "$owner" \
              --arg repo_name "$repo" \
              --arg status "$status" \
              --arg message "$message" \
              --arg my_fork "$my_fork" \
              --arg final_name "$final_fork_name" \
              --argjson renamed "$renamed" \
              --arg fork_status "$fork_status" \
              --arg conflict_strategy "$CONFLICT_STRATEGY" \
              --arg timestamp "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              '{
                repo: $repo,
                owner: $owner,
                repo_name: $repo_name,
                status: $status,
                message: $message,
                my_fork: $my_fork,
                final_fork_name: $final_name,
                renamed: $renamed,
                fork_status: $fork_status,
                conflict_strategy: $conflict_strategy,
                timestamp: $timestamp
              }' > "results/${owner}_${repo}.json" 2>/dev/null || {
                echo "⚠️  保存结果文件失败: ${owner}_${repo}.json"
              }
            
            # 防止rate limit - 每个仓库之间延迟
            echo "⏱️  等待 5 秒..."
            sleep 5
          done
          
          echo "✅ 批次 ${{ matrix.batch.batch_id }} 处理完成"
          
          # 重新启用错误退出
          set -e
          
      - name: Upload batch results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: batch-results-${{ matrix.batch.batch_id }}
          path: results/
          retention-days: 7

  collect-results:
    runs-on: ubuntu-latest
    needs: [prepare, create-batches, fork-sync]
    if: always() && needs.prepare.outputs.total_count > 0
    steps:
      - name: Download all batch results
        uses: actions/download-artifact@v4
        with:
          pattern: batch-results-*
          path: all-results/
          merge-multiple: true

      - name: Generate results table
        run: |
          echo "📊 正在生成结果表格..."
          
          # 创建结果汇总
          echo "# 🎯 AstrBot插件Fork/Sync结果报告" > results_summary.md
          echo "" >> results_summary.md
          echo "**操作时间:** $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> results_summary.md
          echo "**操作模式:** ${{ inputs.dry_run && '🔍 试运行' || '▶️ 实际执行' }}" >> results_summary.md
          echo "**冲突策略:** ${{ inputs.conflict_resolution || 'rename' }}" >> results_summary.md
          echo "**总仓库数:** ${{ needs.prepare.outputs.total_count }}" >> results_summary.md
          echo "" >> results_summary.md
          
          # 统计各种状态
          total=0
          forked=0
          forked_renamed=0
          synced=0
          up_to_date=0
          already_forked=0
          failed=0
          not_found=0
          conflicts=0
          renamed_count=0
          
          # 创建表格头
          echo "## 📋 详细结果" >> results_summary.md
          echo "" >> results_summary.md
          echo "| 仓库 | 状态 | 我的Fork | Fork名称 | 重命名 | 说明 | Fork状态 | 时间 |" >> results_summary.md
          echo "|------|------|----------|----------|--------|------|----------|------|" >> results_summary.md
          
          # 处理所有结果文件
          if [ -d "all-results" ]; then
            for file in all-results/*.json; do
              if [ -f "$file" ]; then
                total=$((total + 1))
                
                # 提取数据
                repo=$(jq -r '.repo' "$file" 2>/dev/null || echo "unknown")
                status=$(jq -r '.status' "$file" 2>/dev/null || echo "unknown")
                message=$(jq -r '.message' "$file" 2>/dev/null || echo "无消息")
                my_fork=$(jq -r '.my_fork' "$file" 2>/dev/null || echo "unknown")
                final_name=$(jq -r '.final_fork_name // .repo_name' "$file" 2>/dev/null || echo "unknown")
                renamed=$(jq -r '.renamed // false' "$file" 2>/dev/null || echo "false")
                fork_status=$(jq -r '.fork_status // "unknown"' "$file" 2>/dev/null || echo "unknown")
                timestamp=$(jq -r '.timestamp' "$file" 2>/dev/null || echo "$(date -u +%Y-%m-%dT%H:%M:%SZ)")
                
                # 格式化时间
                formatted_time=$(date -d "$timestamp" '+%H:%M' 2>/dev/null || echo "N/A")
                
                # 统计重命名
                if [ "$renamed" = "true" ]; then
                  renamed_count=$((renamed_count + 1))
                fi
                
                # 状态图标和统计
                case "$status" in
                  "forked")
                    icon="🍴"
                    forked=$((forked + 1))
                    ;;
                  "forked_renamed")
                    icon="🏷️"
                    forked_renamed=$((forked_renamed + 1))
                    ;;
                  "synced")
                    icon="🔄"
                    synced=$((synced + 1))
                    ;;
                  "up_to_date")
                    icon="✅"
                    up_to_date=$((up_to_date + 1))
                    ;;
                  "already_forked")
                    icon="📁"
                    already_forked=$((already_forked + 1))
                    ;;
                  "fork_failed"|"fork_rename_failed"|"sync_failed"|"auth_failed"|"api_check_failed")
                    icon="❌"
                    failed=$((failed + 1))
                    ;;
                  "not_found")
                    icon="🚫"
                    not_found=$((not_found + 1))
                    ;;
                  "skipped_conflict"|"conflict_detected"|"conflict_pending")
                    icon="⚠️"
                    conflicts=$((conflicts + 1))
                    ;;
                  "will_fork")
                    icon="🔮"
                    ;;
                  "will_fork_renamed")
                    icon="🔮🏷️"
                    ;;
                  "will_sync")
                    icon="🔮"
                    ;;
                  *)
                    icon="❓"
                    ;;
                esac
                
                # 格式化fork状态
                case "$fork_status" in
                  "valid_fork"|"valid_fork_api") fork_status_display="✅ 有效" ;;
                  "wrong_parent") fork_status_display="⚠️ 错误父级" ;;
                  "independent_repo") fork_status_display="🏠 独立仓库" ;;
                  "not_exists") fork_status_display="❌ 不存在" ;;
                  "invalid_fork") fork_status_display="❌ 无效fork" ;;
                  "api_check_failed") fork_status_display="❌ API检查失败" ;;
                  *) fork_status_display="❓ 未知" ;;
                esac
                
                # 重命名状态
                rename_display=""
                if [ "$renamed" = "true" ]; then
                  rename_display="✅ 是"
                else
                  rename_display="❌ 否"
                fi
                
                # 添加到表格
                echo "| [\`$repo\`](https://github.com/$repo) | $icon $status | [\`$my_fork\`](https://github.com/$my_fork) | \`$final_name\` | $rename_display | $message | $fork_status_display | $formatted_time |" >> results_summary.md
              fi
            done
          fi
          
          # 添加统计摘要
          echo "" >> results_summary.md
          echo "## 📊 统计摘要" >> results_summary.md
          echo "" >> results_summary.md
          echo "| 状态 | 数量 | 百分比 |" >> results_summary.md
          echo "|------|------|--------|" >> results_summary.md
          
          if [ $total -gt 0 ]; then
            [ $forked -gt 0 ] && echo "| 🍴 新fork成功 | $forked | $(( forked * 100 / total ))% |" >> results_summary.md
            [ $forked_renamed -gt 0 ] && echo "| 🏷️ 重命名fork成功 | $forked_renamed | $(( forked_renamed * 100 / total ))% |" >> results_summary.md
            [ $synced -gt 0 ] && echo "| 🔄 同步成功 | $synced | $(( synced * 100 / total ))% |" >> results_summary.md
            [ $up_to_date -gt 0 ] && echo "| ✅ 已是最新 | $up_to_date | $(( up_to_date * 100 / total ))% |" >> results_summary.md
            [ $already_forked -gt 0 ] && echo "| 📁 已fork(未同步) | $already_forked | $(( already_forked * 100 / total ))% |" >> results_summary.md
            [ $conflicts -gt 0 ] && echo "| ⚠️ 冲突/跳过 | $conflicts | $(( conflicts * 100 / total ))% |" >> results_summary.md
            [ $failed -gt 0 ] && echo "| ❌ 失败 | $failed | $(( failed * 100 / total ))% |" >> results_summary.md
            [ $not_found -gt 0 ] && echo "| 🚫 仓库不存在 | $not_found | $(( not_found * 100 / total ))% |" >> results_summary.md
          fi
          
          echo "" >> results_summary.md
          echo "**总计:** $total 个仓库" >> results_summary.md
          echo "**自动重命名:** $renamed_count 个仓库" >> results_summary.md
          
          # 添加重命名详情
          if [ $renamed_count -gt 0 ]; then
            echo "" >> results_summary.md
            echo "## 🏷️ 重命名详情" >> results_summary.md
            echo "" >> results_summary.md
            echo "| 原始仓库 | 原名称 | 新名称 | 原因 |" >> results_summary.md
            echo "|----------|--------|--------|------|" >> results_summary.md
            
            for file in all-results/*.json; do
              if [ -f "$file" ]; then
                renamed_check=$(jq -r '.renamed // false' "$file" 2>/dev/null || echo "false")
                if [ "$renamed_check" = "true" ]; then
                  repo=$(jq -r '.repo' "$file" 2>/dev/null || echo "unknown")
                  repo_name=$(jq -r '.repo_name' "$file" 2>/dev/null || echo "unknown")
                  final_name=$(jq -r '.final_fork_name' "$file" 2>/dev/null || echo "unknown")
                  fork_status=$(jq -r '.fork_status' "$file" 2>/dev/null || echo "unknown")
                  
                  reason=""
                  case "$fork_status" in
                    "wrong_parent") reason="错误的父级仓库" ;;
                    "independent_repo") reason="存在同名独立仓库" ;;
                    "invalid_fork") reason="无效的fork" ;;
                    *) reason="名称冲突" ;;
                  esac
                  
                  echo "| [\`$repo\`](https://github.com/$repo) | \`$repo_name\` | \`$final_name\` | $reason |" >> results_summary.md
                fi
              fi
            done
          fi
          
          # 添加建议
          echo "" >> results_summary.md
          echo "## 💡 建议" >> results_summary.md
          echo "" >> results_summary.md
          if [ $failed -gt 0 ]; then
            echo "- ⚠️  有 $failed 个仓库操作失败，建议检查权限或网络问题" >> results_summary.md
          fi
          if [ $conflicts -gt 0 ]; then
            echo "- ⚠️  有 $conflicts 个仓库存在冲突，请检查冲突策略设置" >> results_summary.md
          fi
          if [ $not_found -gt 0 ]; then
            echo "- 🔍 有 $not_found 个仓库不存在，可能已被删除或移动" >> results_summary.md
          fi
          if [ $already_forked -gt 0 ]; then
            echo "- 🔄 有 $already_forked 个已fork仓库未同步，可使用'强制同步'选项更新" >> results_summary.md
          fi
          if [ $renamed_count -gt 0 ]; then
            echo "- 🏷️  自动重命名了 $renamed_count 个fork，避免了名称冲突" >> results_summary.md
            echo "- 📝 重命名的仓库使用了后缀如 '-astrbot', '-fork', '-plugin' 等" >> results_summary.md
          fi
          echo "- 📅 建议启用定期同步保持fork最新" >> results_summary.md
          echo "- 🧹 自动重命名功能可以避免大部分冲突问题" >> results_summary.md
          echo "- 🔄 如果遇到失败，工作流会自动重试，提高成功率" >> results_summary.md
          echo "- ⚙️  可以调整冲突策略：'rename'(自动重命名)、'skip'(跳过)、'interactive'(待处理)" >> results_summary.md
          
          echo "✅ 结果表格生成完成"
          
      - name: Upload results summary
        uses: actions/upload-artifact@v4
        with:
          name: fork-sync-results
          path: results_summary.md
          retention-days: 30

      - name: Display results in step summary
        run: |
          echo "📊 正在添加结果到步骤摘要..."
          cat results_summary.md >> $GITHUB_STEP_SUMMARY

  summary:
    runs-on: ubuntu-latest
    needs: [prepare, create-batches, fork-sync, collect-results]
    if: always()
    steps:
      - name: Final summary
        run: |
          echo "# 🎯 AstrBot插件Fork/Sync操作完成" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "📊 **基本信息:**" >> $GITHUB_STEP_SUMMARY
          echo "- 总仓库数: ${{ needs.prepare.outputs.total_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- 批次数量: ${{ needs.create-batches.outputs.batch_count }}" >> $GITHUB_STEP_SUMMARY
          echo "- 操作模式: ${{ inputs.dry_run && '🔍 试运行' || '▶️ 实际执行' }}" >> $GITHUB_STEP_SUMMARY
          echo "- 强制同步: ${{ inputs.force_sync && '✅ 是' || '❌ 否' }}" >> $GITHUB_STEP_SUMMARY
          echo "- 冲突策略: ${{ inputs.conflict_resolution || 'rename' }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          # 显示各个job的状态
          echo "🔧 **任务状态:**" >> $GITHUB_STEP_SUMMARY
          echo "- 准备阶段: ${{ needs.prepare.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- 批次创建: ${{ needs.create-batches.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- Fork/Sync: ${{ needs.fork-sync.result }}" >> $GITHUB_STEP_SUMMARY
          echo "- 结果收集: ${{ needs.collect-results.result }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ needs.collect-results.result }}" = "success" ]; then
            echo "✅ **详细结果表格已生成！**" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "📋 请查看上方的 \`collect-results\` 步骤获取完整的结果表格。" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "💾 **结果文件:**" >> $GITHUB_STEP_SUMMARY
            echo "- 可在 Artifacts 中下载 \`fork-sync-results\` 文件查看详细报告" >> $GITHUB_STEP_SUMMARY
            echo "- 包含所有仓库的fork状态、重命名信息、链接和时间戳" >> $GITHUB_STEP_SUMMARY
          else
            echo "⚠️  **结果收集状态异常**" >> $GITHUB_STEP_SUMMARY
            echo "- 操作状态: ${{ needs.fork-sync.result }}" >> $GITHUB_STEP_SUMMARY
            echo "- 结果收集: ${{ needs.collect-results.result }}" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "🔍 **可能的原因:**" >> $GITHUB_STEP_SUMMARY
            echo "- 网络超时或API限制" >> $GITHUB_STEP_SUMMARY
            echo "- 某些仓库访问权限问题" >> $GITHUB_STEP_SUMMARY
            echo "- GitHub API临时不可用" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🆕 **新增自动重命名功能:**" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ 智能检测重名冲突并自动重命名fork" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ 多种命名策略：'-astrbot', '-fork', '-plugin', 'astrbot-' 前缀" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ 数字后缀备选方案，确保找到可用名称" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ 完整的重命名记录和统计信息" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ 支持试运行模式预览重命名结果" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🔄 **改进特性:**" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ 增加了重试机制（每个操作最多重试3次）" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ 添加了超时保护，避免长时间阻塞" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ 改进了错误处理，单个仓库失败不影响整批" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ 减少了批次大小和并发数，降低API压力" >> $GITHUB_STEP_SUMMARY
          echo "- ✅ 增加了延迟时间，更好地避免rate limit" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "🔄 **冲突策略说明:**" >> $GITHUB_STEP_SUMMARY
          echo "- 🏷️  **rename**: 自动重命名冲突的fork（推荐）" >> $GITHUB_STEP_SUMMARY
          echo "- ⏭️  **skip**: 跳过冲突的仓库" >> $GITHUB_STEP_SUMMARY
          echo "- 🤔 **interactive**: 记录冲突待手动处理" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "💡 **使用建议:**" >> $GITHUB_STEP_SUMMARY
          echo "- 首次运行建议使用试运行模式预览结果" >> $GITHUB_STEP_SUMMARY
          echo "- 推荐使用 'rename' 策略自动处理冲突" >> $GITHUB_STEP_SUMMARY
          echo "- 定期运行以保持fork同步最新" >> $GITHUB_STEP_SUMMARY
          echo "- 检查重命名的仓库，确保符合预期" >> $GITHUB_STEP_SUMMARY
